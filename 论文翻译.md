# java.util.concurrent  同步器(Synchronizer)框架
#### Doug Lea
## 抽象
在J2SE1.5中，java.util.concurrent包下面的大部分同步器，如locks，Barriers等都由一个基于AbstractQueuedSynchronizer类的框架构成。
这个框架提供一些共有的方法用于自动管理**同步状态**(synchronization state)，线程阻塞(block)，解锁(unblock)状态和线程队列。
这篇论文描述了这个同步器框架的基本原理，设计，实现，使用用例以及最重要的性能。
## 关键字
同步，Java
## 概述
Java1.5版本推出了java.util.concurrent包，其中JCP JSR 166创建了一组支持中等并发级别(medium-level concurrency)类的容器。
这些组件是一组同步器的抽象实现类，其中包含了一个内部的同步状态(比如说，一个锁是否为锁定状态)，一些更新和检查这个状态的操作和
至少一个可以使调用线程阻塞的方法，一个当其他线程改变同步状态时可以恢复线程的方法。比如，各种形式的互斥锁，读写锁，
信号量，栅栏，futures，事件指标器(indicators)和切换队列等。
>
众所周知，几乎所有的同步器都可以互相实现彼此。比如，我们可以用信号量构建ReentrantLock，反之亦然。但是，这么做会带来大量的开销和复杂性，
并且缺失灵活性，这绝对不是一个项目规划的首选。此外，这在概念上也缺乏吸引力。
如果舍弃上面这些设计会从本质上更加自然。开发者不应被强制选择其中一个作为基础去构建其他同步器。
所以，SJR166建立了一个以AbstractQueuedSynchronizer为核心的框架，包中大部分同步器都由其的通用方法实现，开发者也可以实现自己的同步器。
>
剩余的部分我们讨论这个框架的组成，框架设计与实现背后所蕴含的主要思想，使用用例和一些展示框架性能的方法。
##  2要求
### 2.1功能
同步器至少有两种方法：一种可以阻塞调用线程直到同步状态允许它继续的操作，另一种以某种方式改变同步状态使得一个或多个阻塞的线程解锁的操作。
java.util.concurrent包不定义单个统一的同步器API。 一些是通过通用接口定义的（例如锁定），但另一种仅包含专用版本。 所以，获取和发布操作会在
不同等级上采用一系列不同名称和形式。 例如，方法Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get会全部映射到框架的acquire操作。
 但是，该包在各个级别之间的约定保持一致以支持一系列常见的用法。 更有意义的是，每个同步器支持：
* 非阻塞同步尝试（例如，tryLock）以及阻塞版本。
* 可选的超时，所以应用程序可以放弃等待。
* 可中断，通常分成一个获取的操作是可以取消的，而不是其他操作。
同步器可能会根据它们是否仅处于独占状态而有所不同，这种同一时刻只能有一个线程的状态可能继续通过可能的中断点 。与多线程有时进行的共享状态。
当然，普通的锁只保留独占状态，但比如信号量可能会被超过所允许的线程持有。 为了广泛使用，框架必须支持独占和共享这两种操作模式。
java.util.concurrent包也定义了接口Condition，支持监视器模式的await/signal操作这可能与独占的Lock类相关联，并且它们的实现本质上是与它们关联的Lock类交织在一起。
### 2.2 性能目标
Java内置锁（使用同步方法和同步块）一直拥有一些性能问题，并且有一些关于它们的改进的大量文献。 然而，这类工作的主要重点是尽量减少空间开销（因为任何Java对象都可以作为一个锁），
当在大多数单处理器上的单线程环境中使用时，会将空间开销最小化。但这些对于同步器都不是特别重要的问题：程序员只在需要时才构造同步器，所以不需要压缩本来会浪费的空间，并且同步器
几乎完全用于多线程设计（越来越多工作通常在多处理器上），并且对于少量的竞争是可以符合预期的。 但是通常的JVM策略主要针对零竞争案例优化锁定。
其他情况下可预测性较差的“缓慢路径"对于严重依赖于java.util.concurrent的典型多线程服务器应用程序并不是正确的的策略。
相反，这里的主要性能目标是可伸缩性：甚至可预测性地保持效率，尤其是在同步器竞争时。 理想情况下，无论如何，传递同步点所需的开销应该是恒定的，许多线程都试图这样做。
主要目标之一是尽量减少一些线程被允许通过同步点的时间总量。但是，这必须兼顾资源考虑，包括CPU总时间要求，内存流量和线程调度开销。 
例如，自旋锁通常比锁定锁提供更短的采集时间，但通常浪费CPU周期并产生存储器竞争，因此通常不适用。
这些目标一般使用两种一般的方式。 大多数应用程序应该使总吞吐量最大化，可容忍关于饥饿的概率性发生。
但是，在诸如资源控制等应用程序中，保持跨线程访问的公平性更重要，容忍较差的总吞吐量。 没有框架可以决定这些不同用户冲突的地方， 而不是必须执行非公平的策略。
无论内部结构如何精良，同步器都会在某些应用程序中造成性能瓶颈。因此，该框架必须能够监控和检查基本操作，以便用户发现并减少瓶颈。
这最简单（也是最有用的）的思路需要提供一种方法以确定有多少个线程被阻塞。
### 3 设计与实施
一个同步器背后的思想是相当简单直接的。一个获取操作过程如下：
while (synchronization state does not allow acquire) {
    enqueue current thread if not already queued;
    possibly block current thread;
}
dequeue current thread if it was queued;
一个释放操作如下：
update synchronization state;
if (state may permit a blocked thread to acquire)
    unblock one or more queued threads;
支持这些操作需要管理三个基本组件：
1. 原子性管理的同步状态
2. 阻塞和非阻塞线程
3. 等待队列
有可能创建一个允许这三个部分中的每一个独立变化的框架。但是，这既低效也不可用。 例如，信息保留在队列中的节点必须与解锁所需的相匹配，
并且导出方法的签名取决于同步状态。同步器框架的中央设计决策是选择这三者中的每一个的具体实施组件，同时仍然允许存在广泛的选项去使用它们。
这有意限制了适用范围，但提供了足够有效的支持，几乎没有理由不使用框架（而不是在其适用的情况下从头开始构建同步器）。
### 3.1 同步状态
AbstractQueuedSynchronizer类使用一个32位的int来表示同步状态，并且使用getState,setState,CompareAndSetStare操作来访问和更新状态。
这些方法都依赖于java.util.concurrent.atomic，该包提供了与volatile语义一致的读和写操作，并且通过原始的比较并交换或负载连接/存储条件指令
来完成compareAndSetState，这个方法可以原子化去设置一个给定的新值，当且仅当当前值等于一个期望的值。
将同步状态限制为一个32位的int是一个实用的决策。JSR166也提供了一个用于64位的long字段
来进行原子操作，这个仍然必须在大多数平台上使用内部锁，这会导致同步器性能表现不太良好。
在未来，它可能为第二个基础的类，为64位的状态定制使用。然而，现在没有强烈的原因去将它
包含在包中。因为目前32位状态足以满足于大多数的应用。包中只有java.util.cncurrent.synchronizer,
CycliBarrier会需要多余的位来包含状态，所以这些类使用了内部锁。
依赖于AbstractQueuedSynchronizer的具体的类一定需要定义tryAcquire和tryRelease方法，
在这些暴露的状态方法中，可以控制获取和释放操作。tryAcquire方法必须返回true如果同步状态被获取了。
并且tryRelease方法必须返回true，如果新的同步状态可能允许新的获取。在这些方法接受一个单独的int
参数可以用于和期望的同步状态进行交互。比如在可重入锁，在从条件等待返回后重新获取锁时重新建立递归计数。
许多同步器不需要这样的一个参数，所以就忽略它。
### 3.2阻塞
在JSR166之前,没有合适的Java API来阻塞或者解锁线程以用于创建不基于内置锁的同步器。唯一的方法是
Thread.suspend和Thread.resume，但它们遇到了无法解决的竞态问题：如果一个阻塞的线程在另一个阻塞线程执行
resume操作之前调用了resume，那么resume操作会没有效果。java.util.concurrent.locks包包括一个LockSupport类
用以解决这个问题。LockSupport.park阻塞先前线程直到LockSupport.unpark方法执行。unpark方法没有计数效果
所以多个unpark在park方法执行后只解锁一个单独的park。此外，这应用于每个线程而不是每个同步器。
一个线程在一个新的同步器上调用park可能立即返回，因为可能存在剩余的前一个unpark。
然而，在一个启动的情况下，它的下一个调用将阻塞。虽然可以明确地清楚这种情况，但不值得这样做。这是更有效的方法尤其当需要时多次调用。
某种程度上在solaris-9线程库，win32下的“消费事件”和Linux NPTL线程库中这个简单的机制与其使用的机制类似。所以这些在最常见的
java平台上运行且有效。（但是，为了融入现有的运行设计,当前的Sun hotspot JVM引用在Solaris和Linux上使用pthread实现condvar。）
park方法还支持可选的相对和绝对时延，并与JVM Thread.interrupt集成。
### 3.3队列
框架的核心是维护阻塞队列。限制在FIFO队列中的线程。因此，该框架不支持基于优先级的同步。
现在，对于同步队列最合适的选择是没有阻塞的数据结构，它们本身不需要使用较低级别的锁来构建，这一点几乎没有争议。
其中有两个主要候选人：Mellor-Crummey和Scott的变体（MCS）锁和Craig, Landin和Hagersten（CLH）锁。从历史上看，CLH锁仅使用自旋锁。然而，它们似乎比MCS更适合于
同步器框架，因为它们更容易处理取消中断和超时，所以被选为作为队列的基础。这个最终的设计是足以从原来的CLH结构中移除的解释。
    CLH队列跟普通的队列不太一样，因为其入队出队操作与它的用途密切相关的锁。它是一个链接队列通过两原子可更新字段头和尾访问，都指向一个虚拟节点。
CLH锁的优点是，入队出队速度快，无锁和无障碍（即使在争用，一个线程总是会赢得插入操作，所以可以继续进行）
检测线程是否在等待也比较快（只检查头部是否和尾一样）；发布状态是分散的，避免了一些内存竞争。
    在CLH锁的原始版本，他们甚至没有连接节点。在一个自旋锁，pred变量可以保存为本地变量。
然而，Scott和Scherer表明显式地维护节点中的祖先字段，CLH锁可以处理取消超时和其他形式：如果一个
节点的祖先字段取消，节点可以向上滑动以使用上一节点的状态字段。
    其他主要修改需要使用CLH队列挡同步器是提供一个有效的方法节点定位其后继节点。在自旋锁，只需要一个节点
改变它的状态，在下一个旋转时会注意到它。继承者，所以链接是不必要的。但在封锁中同步器，
一个节点需要明确其醒来（启动）继承人.
    AbstractQueuedSynchronizer队列节点包含一个next链接指向到它的继承者。但因为没有适用双链表无锁原子插入技术
节点使用compareAndSet，这个环节不自动设置为插入的一部分；在插入后它被简单地赋值：
pred.next =node；
这反映在所有用法中。next指针只被视为优化方式。如果节点的继承者不存在（或被取消）通过它的next字段，总是可以从列表的尾部和遍历开始。
向后用pred字段准确检查是否真的是一。第二组修改是使用状态字段保存在每个节点的目的是控制阻塞，而不是自旋。在同步器框架，队列线程只能返回。
从获取操作如果它通过tryAcquire方法在具体子类中定义；单个“释放”位不够了。但是仍然需要进行控制以确保活动线程。
只允许调用tryAcquire在头队列；在这种情况下，它可能无法获得或阻塞。这不需要每个节点状态标志，因为权限可以通过检查当前节点的前任是头结点。
和不同的自旋锁的情况下，没有足够的内存竞争头部复制.但是，取消状态仍然必须存在于状态字段。
队列节点状态字段也用于避免不必要的调用。park和unpark。虽然这些方法相对阻塞原语来说比较快。在跨越边界之间的java和JVM运行时或操作系统他们遇到了可避免的开销。
在调用park之前，线程设置一个“signal me”标志位，然后复核同步和节点状态之前再一次调用park。释放线程清除状态。这节省了
线程从不必要的尝试阻塞往往是值得的，尤其是在等待时间丢失的锁类中为下一个合格的线程获得锁加重其他竞争的影响。多个节点来处理一个明显空的next字段，除非signal与取消同时发生。
也许CLH锁与同步器框架结合和那些使用过的语言主要的区别在于垃圾回收依赖于管理存储恢复的节点，它避免了复杂性和开销。
然而，依赖GC仍然需要调链接字段时，他们肯定是永远不会被需要。这通常是出列操作。否则，未使用的节点仍然是可达的，导致被收回。
一些小问题，包括通过CLH队列在第一所需的初始虚拟节点延迟初始化争用，在源代码文档中进行了说明。省略这样的细节，基本获取操作实现的一般形式（独占，不可中断，不定时的情况下）是：
 if (!tryAcquire(arg)) {
    node = create and enqueue new node;
    pred = node's effective predecessor;
    while (pred is not head node || !tryAcquire(arg)) {
        if (pred's signal bit is set)
            park();
        else
            compareAndSet pred's signal bit to true;
            pred = node's effective predecessor;
    }
    head = node;
 }
 释放操作为：
 if (tryRelease(arg) && head node's signal bit is set) {
    compareAndSet head's signal bit to false;
    unpark head's successor, if one exists
 }
当然，tryAcquire性质对主要的迭代次数获得循环依赖。否则，在没有取消的情况下，获取和释放的每个组件都是一个常数
时间O（1）操作，在线程之间进行摊销，不考虑在park内发生的任何OS线程调度。
支持取消主要需要检查中断或在获取循环中的每次返回时超时。
由于超时或中断而取消的线程设置其节点状态并且unparks其继任者可能重置链接。有了取消性，
确定前任和继任者复位状态的复杂度为O（n）（其中n是遍历的队列长度）。
因为一个线程再也不会阻塞取消操作，链接和状态字段会重新稳定快速。
### 3.4条件队列
同步器框架同步器提供了一个ConditionObject类用于独占同步并遵从Lock接口。任何数量的条件对象可能关联到一个锁对象
用来提供监视器类型的await，signal和signalAll操作，包括这些的超时版本。
ConditionObject类使得条件与同步操作更有效率的结合在一起。
重新修复一些设计决策。这个类支持Java风格的的监视器访问规则即当条件满足时拥有该条件的锁才会被线程拥有。因此，
一个ConditionObject关联一个ReentrantLock跟内置的监视器操作方式一样，比如，object.wait等，仅在方法名称、额外功能和事实上有所不同
用户可以声明每个锁的多个条件。
一个ConditionObject使用相同的内部队列节点同步，但维持在一个单独的状态队列。
信号操作被实现为从条件队列到锁队列，不一定要唤醒信号线程在它重新获得锁之前。
基础的await操作为：
create and add new node to condition queue;
release lock;
block until node is on lock queue;
re-acquire lock;
signal操作为：
transfer the first node from condition queue to lock queue;
因为这些操作只在拥有锁时才会执行，所以它们可以使用顺序链接队列的操作（在结点中使用一个nextWaiter字段）来保持
条件队列。trasfer操作简单的将头结点的指针去掉然后使用CLH插入将它关联到一个锁队列。
实现这些操作的主要难点在于分配由于超时或调用Thread.interrupt出现的条件中断
大约在同一时间发生的取消和signal引发竞争符合内置监视器的规格。
作为JSR133的修订，这些要求当一个中断发生前的signal，
然后await必须在重新获得锁后抛出InterruptedException。但是如果它被中断后signal，
那么方法必须返回而不抛出异常，但带有线程中断状态集合。
为了保持正确的排序，队列节点状态中有一记录节点是否已经（或正在进行）转移。
signal代码和取消的代码都调用compareAndSet这个状况。如果信号操作输了该竞争，
它将转移队列中的下一个节点。如果一个取消丢失，必须中止传输，然后等待锁定重新采集。
后一种情况介绍了一个潜在的无界自旋。取消等不能开始锁定位直到节点成功地插入到
锁队列，所以必须自旋等待CLH队列的插入compareAndSet被信号线进行成功。
在这里需要自旋是罕见的，并采用了thread.yield提供调度暗示一些其他线程，
最好是执行信号的线程，应该运行。而有可能在这里实施一个帮助战略。
取消插入节点，情况非常罕见，无法自圆其说。这将带来额外的开销。在所有其他情况下，
其他地方不使用自旋或yield，这保持合理的性能问题。




