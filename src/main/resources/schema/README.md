# java.util.concurrent  同步器(Synchronizer)框架
#### Doug Lea
## 抽象
在J2SE1.5中，java.util.concurrent包下面的大部分同步器，如locks，Barriers等
都由一个基于AbstractQueuedSynchronizer类的小型框架构成。这个框架提供
一些共有的方法用于自动管理**同步状态**(synchronization state)，线程阻塞(block)和解除阻塞(unblock)状态，
和线程队列。这篇论文描述了这个同步器框架的基本原理，设计，实现，使用用例以及最重要的性能。

## 关键字
同步，Java
## 概述
Java1.5版本推出了java.util.concurrent包，其中JCP JSR 166创建了一组支持中等并发级别(medium-level concurrency)类的容器
这些组件是一组同步器的抽象实现类，其中包含了一个内部的同步状态(比如说，一个锁是否为锁定状态)，一些更新和检查这个状态的操作和
至少一个可以使调用线程阻塞的方法和一个当其他线程改变同步状态时可以恢复线程的方法。比如，各种形式的互斥锁，读写锁，
信号量，栅栏，futures，事件指标器(indicators)和切换队列等。
>
众所周知，几乎所有的同步器都可以互相实现对方。比如，我们可以用信号量构建ReentrantLock，反之亦然。但是，这么做会带来大量的开销和复杂性，
并且缺失灵活性，这绝对不是一个项目规划的首选。此外，这在概念上也缺乏吸引力。
如果舍弃上面这些设计会从本质上更加自然。开发者不应被强制选择其中一个作为基础去构建其他同步器。所以，SJR166建立了一个
以AbstractQueuedSynchronizer为核心的小型框架，包中大部分同步器都由其的通用方法实现，开发者也可以实现自己的同步器。
>
剩余的部分我们讨论这个框架的组成，框架设计与实现背后所蕴含的主要思想，使用用例和一些展示框架性能的方法。

